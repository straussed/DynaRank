axis(1, at = ranks$x, labels = ranks$period)
for(id in unique(ranks$id)){
lines(x = ranks[ranks$id == id,'x'], y = ranks[ranks$id == id,'rank'])
}
}else{
plot(x = ranks$period, y = ranks$rank, type = 'n', ylim = ylimit,
xlab = 'Study period', ylab = ylabel, ...)
for(id in unique(ranks$id)){
lines(x = ranks[ranks$id == id,'period'], y = ranks[ranks$id == id,'rank'])
}
}
}
female.elo %>%
select(period, id, score) %>%
rename(rank = score) %>%
plot_ranks()
#' Plot ranks of individuals in a single social group over multiple study periods
#'
#' @param ranks A dataframe of ranks. There should be one row per contestant per
#' study period. There should be three columns:
#'    \describe{
#'      \item{period}{Study periods. They should appear in chronological order.}
#'      \item{id}{The identity of each contestant. Each contestant should appear
#'      once per study period}
#'      \item{rank}{The rank of each contestant in each study period. This can be
#'      absolute rank, standardized rank, or elo scores.}
#'    }
#'
#' @param ... Arguments to be passed to \code{\link{plot}}
#'
#' @export
plot_ranks <- function(ranks, ...){
##Check for standardized ranks vs absolute rank vs elo scores
if(any(ranks$rank > 1 & ranks$rank < 0)){
ylimit <- c(-1,1)
ylabel <- 'Standardize Rank'
}else if(sum(ranks$rank == 1) == length(unique(ranks$period))){
ylimit <- c(max(ranks$rank), 0)
ylabel <- 'Rank'
}else{
ylimit <- c(min(ranks$rank), max(ranks$rank))
ylabel <- 'Score'
}
if(is.factor(ranks$period)){
ranks$period <- as.character(ranks$period)
ranks$x <- as.numeric(factor(ranks$period, levels = unique(ranks$period)))
plot(x = ranks$x, y = ranks$rank, type = 'n', ylim = ylimit,
xlab = 'Study period', ylab = ylabel, ..., xaxt = 'n')
axis(1, at = ranks$x, labels = ranks$period)
for(id in unique(ranks$id)){
lines(x = ranks[ranks$id == id,'x'], y = ranks[ranks$id == id,'rank'])
}
}else if(is.character(ranks$period)){
ranks$x <- as.numeric(factor(ranks$period, levels = unique(ranks$period)))
plot(x = ranks$x, y = ranks$rank, type = 'n', ylim = ylimit,
xlab = 'Study period', ylab = ylabel, ..., xaxt = 'n')
axis(1, at = ranks$x, labels = ranks$period)
for(id in unique(ranks$id)){
lines(x = ranks[ranks$id == id,'x'], y = ranks[ranks$id == id,'rank'])
}
}else{
plot(x = ranks$period, y = ranks$rank, type = 'n', ylim = ylimit,
xlab = 'Study period', ylab = ylabel, ...)
for(id in unique(ranks$id)){
lines(x = ranks[ranks$id == id,'period'], y = ranks[ranks$id == id,'rank'])
}
}
}
female.elo %>%
select(period, id, score) %>%
rename(rank = score) %>%
plot_ranks()
d = 26
3.14159 * d
ranks <- ranks %>%
group_by(period) %>%
mutate(stan.rank = -2*(rank-1)/(max(rank)-1) + 1) %>%
select(period, id, score, rank, stan.rank, old.order) %>%
as.data.frame()
ranks <- female.elo %>%
group_by(period) %>%
mutate(stan.rank = -2*(rank-1)/(max(rank)-1) + 1) %>%
select(period, id, score, rank, stan.rank, old.order) %>%
as.data.frame()
female.elo
ranks
library(devtools)
install_github('straussed/LongiDom')
?LongiDom
library(LongiDom)
?longidom
library(roxygen2)
document()
setwd('LongiDom')
document()
library(devtools)
install_git('straussed/LongiDom')
install_github('straussed/LongiDom')
library(LongiDom)
str(C.crocuta.male$contestants)
?informed_elo
document()
sum(dnorm(c(1,2,3), mean = 10, sd = 0))
sum(dnorm(c(1,2,3), mean = 10, sd = -4))
true.alpha <- -10
true.beta <- .04
x <- runif(1000,min=0, max=100)
y <- rexp(1000, rate = exp(true.alpha*exp(-true.beta*x)))
plot(x,y)
#Negative log link function
#phoned a friend...recommended this to constrain to positive values
neg.log.link<-function(x){
p <- exp(x)
return(p)
}
#	-likelihood
ln.L <- function(y,x,alpha, beta){
p <- neg.log.link(alpha * exp(-beta * x))
return(sum(
dexp(y, rate = p,log=TRUE)
))
}
ln.prior.alpha <- function(alpha){
return(
dnorm(alpha,mean=0,sd=1e6,log=TRUE)
)
}
ln.prior.beta <- function(beta){
return(
dnorm(beta,mean=0,sd=1e6,log=TRUE)
)
}
#	-posterior probability
ln.post.prob <- function(x,y, alpha, beta){
return(
ln.L(x,y,alpha,beta) +
ln.prior.alpha(alpha)+
ln.prior.beta(beta)
)
}
# define the quantities of interest
#	-number of iterations
n.iter <- 1e5
#	-sample frequency
samp.freq <- 2e2
#	-sampled parameter estimates
alpha.sample <- rep(NA,1 + n.iter/samp.freq)
beta.sample <- rep(NA,1 + n.iter/samp.freq)
#	-sampled posterior probability
post.prob.sample <- rep(NA,1 + n.iter/samp.freq)
# initiate the chain
#	-randomly generate parameter values (within prior bounds)
alpha <- runif(1, min=-10, max=10)
beta <- runif(1, min=0, max=10)
#	-calculate posterior probability
post.prob <- ln.post.prob(x=x,y=y,alpha=alpha,beta=beta)
alpha.sample[1] <- alpha
beta.sample[1] <- beta
post.prob.sample[1] <- post.prob
# run the MCMC for the specified number of iterations
for(i in 2:n.iter){
#	in each iteration:
#		-propose an update a parameter value
alpha.prime <- alpha + rnorm(1,0,0.1)
beta.prime <- beta + rnorm(1,0,0.1)
#		-calculate the posterior probability of the data given the proposed value
post.prob.prime <- ln.post.prob(x= x, y = y, beta = beta.prime, alpha = alpha.prime)
#		-calculate R, the ratio of the proposed and current posterior probabilities
R <- exp(post.prob.prime - post.prob)
#		-generate a random, uniformly distributed number between 0 and 1
U <- runif(1,min=0,max=1)
#		-if R is greater than the random draw from U(0,1), accept the move
if(R > U){
#			-new param value is proposed param value
alpha <- alpha.prime
beta <- beta.prime
#			-new posterior probability is the posterior probability of the proposed param value
post.prob <- post.prob.prime
}
#	   # do book-keeping (log parameter values and posterior probability values at pre-specified sampling frequencies
if(i %% samp.freq == 0){
alpha.sample[1+i/samp.freq] <- alpha
beta.sample[1+i/samp.freq] <- beta
post.prob.sample[1+i/samp.freq] <- post.prob
}
}
layout(matrix(c(1,4,2,5,3,6,rep(7,4),rep(8,4)),nrow=2,ncol=7))
#	plot parameter and posterior probability traces
plot(1,alpha.sample[1],xlim=c(1,length(alpha.sample)),ylim=range(c(alpha.sample,true.alpha)),xlab="sampled MCMC iterations",ylab="alpha parameter estimates",main="alpha",pch=20,col=adjustcolor(1,0.4))
dev.off()
#	plot parameter and posterior probability traces
plot(1,alpha.sample[1],xlim=c(1,length(alpha.sample)),ylim=range(c(alpha.sample,true.alpha)),xlab="sampled MCMC iterations",ylab="alpha parameter estimates",main="alpha",pch=20,col=adjustcolor(1,0.4))
abline(h=true.alpha,col=2,lwd=0.5)
mean(alpha.sample)
true.alpha*exp(-true.beta*x)
exp(true.alpha*exp(-true.beta*x)))
exp(true.alpha*exp(-true.beta*x))
rexp(1000, rate = exp(true.alpha*exp(-true.beta*x)))
?exp
?rexp
mean(rexp(n = 10000, rate = -10))
mean(rexp(n = 10000, rate = 10))
mean(rexp(n = 10000, rate = 4))
1e5
# define the quantities of interest
#	-number of iterations
n.iter <- 4e5
#	-sample frequency
samp.freq <- 2e2
#	-sampled parameter estimates
alpha.sample <- rep(NA,1 + n.iter/samp.freq)
beta.sample <- rep(NA,1 + n.iter/samp.freq)
#	-sampled posterior probability
post.prob.sample <- rep(NA,1 + n.iter/samp.freq)
# initiate the chain
#	-randomly generate parameter values (within prior bounds)
alpha <- runif(1, min=-10, max=10)
beta <- runif(1, min=0, max=10)
#	-calculate posterior probability
post.prob <- ln.post.prob(x=x,y=y,alpha=alpha,beta=beta)
alpha.sample[1] <- alpha
beta.sample[1] <- beta
post.prob.sample[1] <- post.prob
# run the MCMC for the specified number of iterations
for(i in 2:n.iter){
#	in each iteration:
#		-propose an update a parameter value
alpha.prime <- alpha + rnorm(1,0,0.1)
beta.prime <- beta + rnorm(1,0,0.1)
#		-calculate the posterior probability of the data given the proposed value
post.prob.prime <- ln.post.prob(x= x, y = y, beta = beta.prime, alpha = alpha.prime)
#		-calculate R, the ratio of the proposed and current posterior probabilities
R <- exp(post.prob.prime - post.prob)
#		-generate a random, uniformly distributed number between 0 and 1
U <- runif(1,min=0,max=1)
#		-if R is greater than the random draw from U(0,1), accept the move
if(R > U){
#			-new param value is proposed param value
alpha <- alpha.prime
beta <- beta.prime
#			-new posterior probability is the posterior probability of the proposed param value
post.prob <- post.prob.prime
}
#	   # do book-keeping (log parameter values and posterior probability values at pre-specified sampling frequencies
if(i %% samp.freq == 0){
alpha.sample[1+i/samp.freq] <- alpha
beta.sample[1+i/samp.freq] <- beta
post.prob.sample[1+i/samp.freq] <- post.prob
}
}
mean(alpha.sample)
true.beta
mean(beta.sample)
exp(beta.sample)
exp(mean(beta.sample))
log(mean(beta.sample))
mean(beta.sample)
runif(1, min=-10, max=10)
runif(1, min=0, max=10)
#	-likelihood
ln.L <- function(x,y,alpha, beta){
p <- neg.log.link(alpha * exp(-beta * x))
return(sum(
dexp(y, rate = p,log=TRUE)
))
}
# define the quantities of interest
#	-number of iterations
n.iter <- 1e5
#	-sample frequency
samp.freq <- 2e2
#	-sampled parameter estimates
alpha.sample <- rep(NA,1 + n.iter/samp.freq)
beta.sample <- rep(NA,1 + n.iter/samp.freq)
#	-sampled posterior probability
post.prob.sample <- rep(NA,1 + n.iter/samp.freq)
# initiate the chain
#	-randomly generate parameter values (within prior bounds)
alpha <- runif(1, min=-10, max=10)
beta <- runif(1, min=0, max=10)
#	-calculate posterior probability
post.prob <- ln.post.prob(x=x,y=y,alpha=alpha,beta=beta)
alpha.sample[1] <- alpha
beta.sample[1] <- beta
post.prob.sample[1] <- post.prob
# run the MCMC for the specified number of iterations
for(i in 2:n.iter){
#	in each iteration:
#		-propose an update a parameter value
alpha.prime <- alpha + rnorm(1,0,0.1)
beta.prime <- beta + rnorm(1,0,0.1)
#		-calculate the posterior probability of the data given the proposed value
post.prob.prime <- ln.post.prob(x= x, y = y, beta = beta.prime, alpha = alpha.prime)
#		-calculate R, the ratio of the proposed and current posterior probabilities
R <- exp(post.prob.prime - post.prob)
#		-generate a random, uniformly distributed number between 0 and 1
U <- runif(1,min=0,max=1)
#		-if R is greater than the random draw from U(0,1), accept the move
if(R > U){
#			-new param value is proposed param value
alpha <- alpha.prime
beta <- beta.prime
#			-new posterior probability is the posterior probability of the proposed param value
post.prob <- post.prob.prime
}
#	   # do book-keeping (log parameter values and posterior probability values at pre-specified sampling frequencies
if(i %% samp.freq == 0){
alpha.sample[1+i/samp.freq] <- alpha
beta.sample[1+i/samp.freq] <- beta
post.prob.sample[1+i/samp.freq] <- post.prob
}
}
mean(alpha.sample)
mean(beta.sample)
tblHyenas <- read.csv('~/Documents/Research/LongiDom/tblHyenas.csv')
tblAggressions <- read.csv('~/Documents/Research/LongiDom/tblAggression.csv')
tblHyenas$first.seen <- as.Date(tblHyenas$first.seen)
tblHyenas$disappeared <- as.Date(tblHyenas$disappeared)
tblHyenas$birthdate <- as.Date(tblHyenas$birthdate)
tblHyenas$death.date <- as.Date(tblHyenas$death.date)
#####Assemble male dataset####
tblHyenas <- read.csv('~/Documents/Research/LongiDom/prep/tblHyenas.csv')
tblAggressions <- read.csv('~/Documents/Research/LongiDom/prep/tblAggression.csv')
tblHyenas$first.seen <- as.Date(tblHyenas$first.seen)
tblHyenas$disappeared <- as.Date(tblHyenas$disappeared)
tblHyenas$birthdate <- as.Date(tblHyenas$birthdate)
tblHyenas$death.date <- as.Date(tblHyenas$death.date)
males <- filter(tblHyenas, clan == 'talek', status %in%  c('i', 'immigrant'), sex == 'm')
tblHyenas$status
library(dplyr)
males <- filter(tblHyenas, clan == 'talek', status %in%  c('i', 'immigrant'), sex == 'm')
males
which(males$first.seen == males$disappeared)
##add males that never disperse - include them after they turn 5
males <- rbind(males, filter(tblHyenas, id %in% c('foz', 'ldv', 'pene', 'ziti')))
tblHyenas[tblHyenas$id %in% c('foz', 'ldv', 'pene','ziti'),]$first.seen <-
tblHyenas[tblHyenas$id %in% c('foz', 'ldv', 'pene','ziti'),]$birthdate + 365*5
tblHyenas[tblHyenas$id == 'gaza','first.seen'] <- tblHyenas[tblHyenas$id == 'gaza','birthdate']
males <- males[order(males$first.seen),]
View(males)
males$end.year <- as.numeric(format(do.call(pmin, c(males[,c('death.date', 'disappeared')], na.rm = T)), '%Y'))
males <- males[,c('id', 'first.seen', 'end.year')]
males$start.year <- as.numeric(format(males$first.seen, '%Y'))
###Crocuta crocuta male contestants
ids <- filter(males, start.year < 1996, end.year >= 1988)
ids <- na.omit(ids)
ids <- filter(ids, start.year <= end.year)
ids
arrange(ids, start.year, end.year)
data("C.crocuta.male")
male.ranks <- longidom(contestants = C.crocuta.male$contestants, convention = 'tenure',
n = 50, shuffles = 50, require.corroboration = TRUE,
initial.ranks = C.crocuta.male$initial.ranks,
interactions = C.crocuta.male$interactions)
male.ranks %>%
select(period, id, rank) %>%
#  rename(rank = stan.rank) %>%
plot_ranks()
ids
male.ranks
ids
filter(tblHyenas, id == 'quai')
edgelist_to_matrix(C.crocuta.male$interactions[,1:2])
edgelist_to_matrix(C.crocuta.male$interactions[,1:2], identities = male.ranks$id[male.ranks$period == 1990])
filter(C.crocuta.male$interactions, period = 1990)
filter(C.crocuta.male$interactions, period == 1990)
filter(C.crocuta.male$interactions, period == 1990) %>% edgelist_to_matrix(identities = filter(male.ranks, period == 1990))
filter(C.crocuta.male$interactions, period == 1990)[,1:2] %>% edgelist_to_matrix(identities = filter(male.ranks, period == 1990))
filter(C.crocuta.male$interactions, period == 1990)[,1:2] %>% edgelist_to_matrix(identities = filter(male.ranks, period == 1990)$id)
filter(C.crocuta.male$interactions, period == 1990)[,1:2] %>% edgelist_to_matrix(identities = filter(male.ranks, period == 1990)$id)
ids
arrange(ids, first.seen)
filter(C.crocuta.male$interactions, period == 1989)[,1:2] %>% edgelist_to_matrix(identities = filter(male.ranks, period == 1989)$id)
male_contestants
males <- filter(tblHyenas, Clan == 'talek', Status %in%  c('i', 'immigrant'), Sex == 'm')
##add males that never disperse - include them after they turn 5
males <- rbind(males, filter(tblHyenas, ID %in% c('foz', 'ldv', 'pene', 'ziti')))
tblHyenas[tblHyenas$ID %in% c('foz', 'ldv', 'pene','ziti'),]$FirstSeen <-
tblHyenas[tblHyenas$ID %in% c('foz', 'ldv', 'pene','ziti'),]$Birthdate + 365*5
males <- males[order(males$FirstSeen),]
males$EndYear <- format(do.call(pmin, c(males[,c('DeathDate', 'LastSeen', 'Disappeared')], na.rm = T)), '%Y')
males <- males[,c('ID', 'FirstSeen', 'EndYear')]
male_contestants <- list()
for(year in 1988:2013){
male_contestants[[year - 1987]] <- data.frame(filter(males, format(FirstSeen, '%Y') <= year, EndYear >= year), Year = year)
}
male_contestants <- do.call(rbind, male_contestants)
filter(tblHyenas, id == 'quai')
filter(C.crocuta.male$contestants, period == 1988)
male.ranks <- longidom(contestants = C.crocuta.male$contestants, convention = 'tenure',
n = 10, shuffles = 500, require.corroboration = TRUE,
initial.ranks = C.crocuta.male$initial.ranks,
interactions = C.crocuta.male$interactions)
male.ranks %>%
select(period, id, rank) %>%
#  rename(rank = stan.rank) %>%
plot_ranks()
document()
document()
###Read and tidy data
known_mortality <- read.csv("/Volumes/Holekamp/CurrentGradStudents/StraussEli/Infanticide/known_mortality.csv")
unique(known_mortality$mortality)
known_mortality <- filter(known_mortality, mortality!="unknown")
###############Analyze Infant Mortality-Ally Brown 24 October, 2018##############
###Load libraries and set global options
library(tidyverse)
options(stringsAsFactors = FALSE)
###Read and tidy data
known_mortality <- read.csv("/Volumes/Holekamp/CurrentGradStudents/StraussEli/Infanticide/known_mortality.csv")
unique(known_mortality$mortality)
known_mortality <- filter(known_mortality, mortality!="unknown")
###Plot frequency of mortality sources
summarized_mortality <- summarize(select(group_by(known_mortality,mortality),mortality),frequency = length(mortality))
summarized_mortality$frequency <- summarized_mortality$frequency/sum(summarized_mortality$frequency)
summarized_mortality <- arrange(summarized_mortality,desc(frequency))
barplot(names.arg=summarized_mortality$mortality,height = summarized_mortality$frequency, ylim = c(0,.5))
load("~/Documents/Research/Longitudinal_Hierarchies/pub_plots.RData")
mranks[mranks$ID == 'quai']
mranks[mranks$ID == 'quai',]
ggplot(data = filter(mranks, Year >= 1989, Year <= 2013), aes(y = Rank, x = Year)) +
ylim(30,0)+
theme_classic() +
geom_line(aes(y = Rank, x = Year, group = ID), col = viridis(6)[1])+
ggtitle('a) CRAM')
library(viridis)
ggplot(data = filter(mranks, Year >= 1989, Year <= 2013), aes(y = Rank, x = Year)) +
ylim(30,0)+
theme_classic() +
geom_line(aes(y = Rank, x = Year, group = ID), col = viridis(6)[1])+
ggtitle('a) CRAM')
mranks
mranks[mranks$ID == 'quai']
mranks[mranks$ID == 'quai',]
ggplot(data = filter(mranks, Year >= 1988, Year <= 2013), aes(y = Rank, x = Year)) +
ylim(30,0)+
theme_classic() +
geom_line(aes(y = Rank, x = Year, group = ID), col = viridis(6)[1])+
ggtitle('a) CRAM')
ggplot(data = filter(mranks, Year >= 1988, Year <= 2005), aes(y = Rank, x = Year)) +
ylim(30,0)+
theme_classic() +
geom_line(aes(y = Rank, x = Year, group = ID), col = viridis(6)[1])+
ggtitle('a) CRAM')
male.ranks %>%
select(period, id, rank) %>%
#  rename(rank = stan.rank) %>%
plot_ranks()
par(mfrow(2,1))
par(mfrow = c(2,1))
mranks %>% rename(period = Year, id = ID, rank = Rank) %>% plot_ranks
mranks %>% filter(Year >= 1988, Year <= 2005) %>% rename(period = Year, id = ID, rank = Rank) %>% plot_ranks
mranks %>% filter(Year >= 1988, Year <= 2005) %>% rename(period = Year, id = ID, rank = Rank) %>% plot_ranks
male.ranks %>%
select(period, id, rank) %>%
#  rename(rank = stan.rank) %>%
plot_ranks()
mranks %>% filter(Year >= 1988, Year <= 1995) %>% rename(period = Year, id = ID, rank = Rank) %>% plot_ranks
male.ranks %>%
select(period, id, rank) %>%
#  rename(rank = stan.rank) %>%
plot_ranks()
ids
males
#####Assemble male dataset####
tblHyenas <- read.csv('~/Documents/Research/LongiDom/prep/tblHyenas.csv')
tblAggressions <- read.csv('~/Documents/Research/LongiDom/prep/tblAggression.csv')
tblHyenas$first.seen <- as.Date(tblHyenas$first.seen)
tblHyenas$disappeared <- as.Date(tblHyenas$disappeared)
tblHyenas$birthdate <- as.Date(tblHyenas$birthdate)
tblHyenas$death.date <- as.Date(tblHyenas$death.date)
males <- filter(tblHyenas, clan == 'talek', status %in%  c('i', 'immigrant'), sex == 'm')
##add males that never disperse - include them after they turn 5
males <- rbind(males, filter(tblHyenas, id %in% c('foz', 'ldv', 'pene', 'ziti')))
tblHyenas[tblHyenas$id %in% c('foz', 'ldv', 'pene','ziti'),]$first.seen <-
tblHyenas[tblHyenas$id %in% c('foz', 'ldv', 'pene','ziti'),]$birthdate + 365*5
tblHyenas[tblHyenas$id == 'gaza','first.seen'] <- tblHyenas[tblHyenas$id == 'gaza','birthdate']
males <- males[order(males$first.seen),]
males$end.year <- as.numeric(format(do.call(pmin, c(males[,c('death.date', 'disappeared')], na.rm = T)), '%Y'))
males <- males[,c('id', 'first.seen', 'end.year')]
males$start.year <- as.numeric(format(males$first.seen, '%Y'))
###Crocuta crocuta male contestants
ids <- filter(males, start.year < 1996, end.year >= 1988)
ids <- na.omit(ids)
ids <- filter(ids, start.year <= end.year)
contestants <- data.frame()
for(ID in ids$id){
contestants <- rbind(contestants, data.frame(id = ID,
first.seen = filter(ids, id == ID)$first.seen,
period = seq(from =filter(ids, id == ID)$start.year, to = filter(ids, id == ID)$end.year, by = 1)))
}
contestants <- filter(contestants, period >= 1988, period <= 1995)
contestants <- arrange(contestants, period, first.seen)
contestants$convention1 <- contestants$first.seen
contestants <- contestants %>% select(period, id, convention1)
contestants
male.ranks %>%
select(period, id, rank) %>%
#  rename(rank = stan.rank) %>%
plot_ranks(col = as.factor(male.ranks$id))
male.ranks %>%
select(period, id, rank) %>%
#  rename(rank = stan.rank) %>%
plot_ranks(col = as.numeric(as.factor(male.ranks$id)))
as.numeric(as.factor(male.ranks$id))
rep(rainbow(9))
rep(rainbow(9), 100)
male.ranks %>%
select(period, id, rank) %>%
#  rename(rank = stan.rank) %>%
plot_ranks(col = rep(rainbow(9),100)[as.numeric(as.factor(male.ranks$id))])
par(mrow = c(1,1))
par(mfrow = c(1,1))
